ä½ æ˜¯ aeron å¼€æºé¡¹ç›®çš„ä¸“å®¶ï¼Œæˆ‘æœ‰é—®é¢˜è¦é—®ä½ ã€‚æˆ‘çš„ç¯å¢ƒæ˜¯ MACOSï¼Œå¼€å‘å·¥å…·ä½¿ç”¨çš„æ˜¯ IDEAï¼Œé¡¹ç›®ä½¿ç”¨äº† maven ã€‚java version "25" 2025-09-16 LTSï¼Œpom.xml é…ç½®å¦‚ä¸‹
Â·Â·Â·xml
<dependency>
    <groupId>io.aeron</groupId>
    <artifactId>aeron-all</artifactId>
    <version>1.48.6</version>
</dependency>

<dependency>
    <groupId>uk.co.real-logic</groupId>
    <artifactId>sbe-tool</artifactId>
    <version>1.35.6</version>
</dependency>
```

ä½ å›ç­”æˆ‘æ—¶éœ€è¦ç”¨ç®€ä½“ä¸­æ–‡ã€‚

å¸®æˆ‘çœ‹ä¸‹æˆ‘ä¸‹é¢çš„ä»£ç ï¼Œå…³äº Aeron çš„æ¶ˆæ¯å‘å¸ƒï¼Œtest æ˜¯æµ‹è¯•ä»£ç ï¼Œcount = 10ã€‚
ä¸‹é¢çš„ communication.call(requestMessage); ä¼šæŠŠ requestMessage æ”¾å…¥åˆ° DefaultPublisher.publishMessage æ–¹æ³•ä¸­ã€‚
å†…éƒ¨ä½¿ç”¨çš„æ˜¯ DefaultFutureManager æ¥åˆ›å»º CompletableFutureï¼Œä½ çœ‹ä¸‹æœ‰ä¼˜åŒ–çš„ç©ºé—´å—ã€‚

æµ‹è¯•æ–¹æ³•è€—æ—¶å¤§çº¦æ˜¯ millis:23 ï¼Œç°åœ¨æˆ‘ä¸»è¦ç›¸å…³ä¼˜åŒ–å•æ¬¡ RTT çš„æ—¶é—´ã€‚
ç°åœ¨æµ‹å‡ºä» EnterprisePublisher publication.offer(buffer, 0, limit); è¿™é‡Œå‘å‡ºæ¶ˆæ¯åˆ° RequestMessageOnFragment æ¥æ”¶å¤„ç† ï¼Œç”¨äº†å¤§æ¦‚ 800 å¾®å¦™ï¼Œ
ä¸æ˜¯è¯´ aeron æ˜¯çº³ç§’çº§çš„å—ï¼Œä¸ºä»€ä¹ˆè¿˜ç”¨äº† 800 å¾®å¦™ï¼Œæ‰“å°æ•°æ®å¦‚ä¸‹
```text
30:22.992 [Publisher] [] INFO  extracted(EnterprisePublisher.java:106) publish userId:1 - 248
30:22.993 [Net] [] INFO  process(RequestMessageOnFragment.java:69) userId:1 - 1012
30:22.995 [Publisher] [] INFO  extracted(EnterprisePublisher.java:106) publish userId:2 - 170
30:22.996 [Net] [] INFO  process(RequestMessageOnFragment.java:69) userId:2 - 1061
```

spring mvc test æ–¹æ³•çš„æ‰“å°å¦‚ä¸‹
```text
millis:25
avgMicrosTime:363

title: call-FutureTimes
size: 10
sumTime: 282,520
avgMicros: 28
avgMillis: 0
-----------------------

title: call-requestSbeTimes
size: 10
sumTime: 359,419
avgMicros: 35
avgMillis: 0
-----------------------


title: requestOnFragmentTimes
size: 10
sumTime: 1,638,088
avgMicros: 163
avgMillis: 0
-----------------------

title: handleTimes
size: 10
sumTime: 1,137,899
avgMicros: 113
avgMillis: 0
-----------------------

title: responseSbeTimes
size: 10
sumTime: 240,395
avgMicros: 24
avgMillis: 0
-----------------------
```


@RestController
@RequestMapping("gm")
public final class GameManagerController {
    @GetMapping("/test/{count}")
    public String test(@PathVariable int count) throws InterruptedException {

        DevKit.reset();

        var cmd = GameManagerCmd.of(GameManagerCmd.test);
        var communication = CommunicationKit.getCommunication();
        long nanoTime = System.nanoTime();

        for (int i = 1; i <= count; i++) {
            var requestMessage = communication.ofRequestMessage(cmd, i);
            requestMessage.bindingUserId(i);
            // ... set message properties ...
            var response = communication.call(requestMessage);
        }

        var millis = TimeKit.elapsedMillis(nanoTime);

        TimeUnit.MILLISECONDS.sleep(100);

        String ofFutureTimes = DevKit.toString("call-FutureTimes", DevKit.ofFutureTimes);
        String requestSbeTimes = DevKit.toString("call-requestSbeTimes", DevKit.requestSbeTimes);

        String requestOnFragmentTimes = DevKit.toString("requestOnFragmentTimes", DevKit.requestOnFragmentTimes);
        String handleTimes = DevKit.toString("handleTimes", DevKit.handleTimes);
        String responseSbeTimes = DevKit.toString("responseSbeTimes", DevKit.responseSbeTimes);

        return """
                millis:%,d
                avgMicrosTime:%,d

                %s
                %s

                %s
                %s
                %s
                """.formatted(millis
                , DevKit.avgMicrosTime.sum()

                , ofFutureTimes
                , requestSbeTimes

                , requestOnFragmentTimes
                , handleTimes
                , responseSbeTimes
        ).replaceAll("\n", "<br/>");
    }
}


DefaultCommunicationAggregation ä¼šè¢«å¤šä¸ªçº¿ç¨‹è°ƒç”¨ã€‚
@FieldDefaults(level = AccessLevel.PROTECTED)
public class DefaultCommunicationAggregation implements CommunicationAggregation, NetServerSettingAware {
    ...
    @Override
    public Response call(RequestMessage message) {
        CompletableFuture<Response> future = null;

        try {
            long nanoTime = System.nanoTime();
            message.setNanoTime(nanoTime);
            future = callFuture(message);
            DevKit.ofFutureTimes(nanoTime);
            var response = future.get(futureTimeoutMillis, TimeUnit.MILLISECONDS);

            DevKit.ofFutureGetTimes(nanoTime);

            return response;
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            log.warn("call timeout: {}", e.getMessage());

            var response = new ResponseMessage();
            response.setError(ActionErrorEnum.internalCommunicationError);
            this.futureManager.remove(message.getFutureId());
            return response;
        }
    }

    @Override
    public CompletableFuture<Response> callFuture(RequestMessage message) {
        var server = this.findServer.getServer(message);
        if (server == null) {
            return ofErrorFuture(message.getOutputError());
        }

        if (message.getHopCount() == 0) {
            message.setHopCount(2);
        }

        var futureId = this.futureManager.nextFutureId();
        message.setFutureId(futureId);

        if (message.getSourceServerId() == 0) {
            message.setSourceServerId(server.id());
        }

        publishMessage(server.pubName(), message);
        return this.futureManager.ofFuture(futureId);
    }

}

ShardedFutureManager ä¼šè¢«å¤šä¸ªçº¿ç¨‹è°ƒç”¨ï¼Œshards = 32ã€‚

@Slf4j
public class ShardedFutureManager implements FutureManager {
    private static final class FutureHolder extends CompletableFuture<Object> {
        final long createTimeNanos = TimeCacheKit.currentNanoTime();
    }

    final int shardLength;
    final ConcurrentHashMap<Long, FutureHolder>[] shardMaps;
    final AtomicLong idGenerator = new AtomicLong(1);
    final ScheduledExecutorService cleaner;
    final long timeoutNanos;
    int shardIndex = 0;

    @SuppressWarnings("unchecked")
    public ShardedFutureManager(int shards, final long timeoutMillis) {
        if (Integer.bitCount(shards) != 1) {
            throw new IllegalArgumentException("shards must be power of two for fast mod");
        }

        this.shardLength = shards - 1;
        this.timeoutNanos = TimeUnit.MILLISECONDS.toNanos(timeoutMillis);
        this.shardMaps = new ConcurrentHashMap[shards];
        for (int i = 0; i < shards; i++) {
            this.shardMaps[i] = new ConcurrentHashMap<>();
        }

        this.cleaner = ExecutorKit.newSingleScheduled("FutureCleaner");
        this.cleaner.scheduleAtFixedRate(this::cleanTimeouts, timeoutMillis, 100, TimeUnit.MILLISECONDS);
    }

    private ConcurrentHashMap<Long, FutureHolder> shardFor(long futureId) {
        return shardMaps[(int) (futureId & shardLength)];
    }

    @Override
    public long nextFutureId() {
        return idGenerator.getAndIncrement();
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> CompletableFuture<T> ofFuture(long futureId) {
        var holder = new FutureHolder();

        shardFor(futureId).put(futureId, holder);
        return (CompletableFuture<T>) holder;
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> CompletableFuture<T> remove(long futureId) {
        var holder = shardFor(futureId).remove(futureId);
        if (holder == null) {
            return null;
        }

        return (CompletableFuture<T>) holder;
    }


    private void cleanTimeouts() {
        final long now = System.nanoTime();
        ConcurrentHashMap<Long, FutureHolder> shard = shardMaps[shardIndex];
        shardIndex = (shardIndex + 1) & shardLength;

        for (Iterator<Map.Entry<Long, FutureHolder>> it = shard.entrySet().iterator(); it.hasNext(); ) {
            var e = it.next();
            var h = e.getValue();
            if (h == null) continue;

            if (h.isDone()) {
                it.remove();
                continue;
            }

            if (now - h.createTimeNanos > timeoutNanos) {
                if (h.completeExceptionally(new TimeoutException("future timeout"))) {
                    it.remove();
                }
            }
        }
    }
}

public interface FutureManager {
    long nextFutureId();

    <T> CompletableFuture<T> ofFuture(long futureId);

    <T> CompletableFuture<T> remove(long futureId);

    default void complete(FutureMessage message){
        long futureId = message.getFutureId();
        var future = remove(futureId);
        if (future != null) {
            future.complete(message);
        }
    }
}


DefaultPublisher ä¼šè¢«å¤šä¸ªçº¿ç¨‹è°ƒç”¨ã€‚

@Slf4j
@SuppressWarnings("all")
@FieldDefaults(level = AccessLevel.PROTECTED)
public class DefaultPublisher implements Publisher {
    final Map<String, Publication> publicationMap = CollKit.ofConcurrentHashMap();
    final Map<String, Queue<Object>> messageQueueMap = CollKit.ofConcurrentHashMap();
    volatile boolean running = true;
    ExecutorService executorService;
    AtomicBoolean startup = new AtomicBoolean(false);
    PublisherRunnable publisherRunnable;


    @Override
    public void addPublication(String name, Publication publication) {
        publicationMap.put(name, publication);
        messageQueueMap.putIfAbsent(name, new ManyToOneConcurrentArrayQueue<>(2048));
    }

    @Override
    public void publishMessage(String name, Object message) {
        var queue = messageQueueMap.get(name);
        if (queue != null) {
            queue.offer(message);
        }
    }

    @Override
    public void startup() {
        if (startup.get()) {
            return;
        }

        if (startup.compareAndSet(false, true)) {
            var threadFactory = ExecutorKit.createSigleThreadFactory("Publisher");
            executorService = ExecutorKit.newSingleThreadExecutor(threadFactory);
            executorService.submit(this.getPublisherRunnable());
        }
    }

    protected void close() {
        publicationMap.values().forEach(Publication::close);
    }

    @Override
    public void shutdown() {
        running = false;
        if (executorService != null) {
            executorService.shutdown();
        }
    }

    @Override
    public PublisherRunnable getPublisherRunnable() {

        return publisherRunnable;
    }
}

EnterprisePublisher ä¼šè¢«å¤šä¸ªçº¿ç¨‹è°ƒç”¨ã€‚

@Slf4j
public final class EnterprisePublisher extends DefaultPublisher {
    @Override
    public PublisherRunnable getPublisherRunnable() {
        if (publisherRunnable == null) {
            publisherRunnable = new EnterprisePublisherRunnable();
        }

        return publisherRunnable;
    }

    private class EnterprisePublisherRunnable implements PublisherRunnable {
        private final UnsafeBuffer buffer = new UnsafeBuffer(new byte[CoreGlobalConfig.publisherBufferSize]);
        private final MessageHeaderEncoder headerEncoder = new MessageHeaderEncoder();
        final IdleStrategy idleStrategy = new BackoffIdleStrategy(
                1, 10, TimeUnit.MICROSECONDS.toNanos(1), TimeUnit.MICROSECONDS.toNanos(100));

        @Override
        public void run() {
            try {
                while (running) {
                    extracted();
                }
            } catch (Exception e) {
                log.error(e.getMessage(), e);
            } finally {
                close();
            }
        }

        private void extracted() {
            boolean messagesPublished = false;

            for (String key : messageQueueMap.keySet()) {
                var queue = messageQueueMap.get(key);
                var publication = publicationMap.get(key);

                if (queue == null || publication == null) {
                    continue;
                }

                Object message;
                while ((message = queue.poll()) != null) {
                    messagesPublished = true;
                    long nanoTime = System.nanoTime();

                    MessageSbe<Object> encoder = SbeMessageManager.getMessageEncoder(message.getClass());
                    if (encoder == null) {
                        log.error("MessageSBEEncoder Error: {} not exist!", message.getClass().getSimpleName());
                        continue;
                    }

                    encoder.encoder(message, headerEncoder, buffer);
                    int limit = encoder.limit();

                    // Aeron.offer() æ˜¯éé˜»å¡çš„ï¼Œå¦‚æœ Publication back-pressures (æ¯”å¦‚ L_NOT_CONNECTED, BACK_PRESSURED)ï¼Œ
                    // æœ€ä½³å®è·µæ˜¯å°†å…¶æ”¾å›é˜Ÿåˆ—å¤´éƒ¨æˆ–æ”¾å…¥ä¸€ä¸ªä¸´æ—¶é‡è¯•é˜Ÿåˆ—ã€‚
                    // ä½†å¯¹äºç®€å•çš„å®ç°ï¼Œæš‚æ—¶åªå…³æ³¨æˆåŠŸå‘é€å’Œæ€§èƒ½æå‡ã€‚

                    if (message instanceof RequestMessage requestMessage) {
                        DevKit.requestSbeTimes(nanoTime);
                        log.info("publish userId:{} - {}", requestMessage.getUserId(),
                                TimeKit.elapsedMicros(requestMessage.getNanoTime())
                        );
                    } else {
                        DevKit.responseSbeTimes(nanoTime);
                    }

                    long result = publication.offer(buffer, 0, limit);


                    if (result < 0) {
                        // **é‡è¦ï¼šå¤„ç†èƒŒå‹ (Back-Pressure) æˆ–é”™è¯¯**
                        // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œä½ éœ€è¦è€ƒè™‘å¦‚ä½•å¤„ç† L_NOT_CONNECTED, BACK_PRESSURED ç­‰æƒ…å†µã€‚
                        // ç®€å•çš„åšæ³•æ˜¯ log é”™è¯¯ï¼Œç„¶å continue æˆ– break å†…éƒ¨å¾ªç¯ã€‚
                        // æ›´ä¼˜çš„åšæ³•æ˜¯æŠŠæ¶ˆæ¯æ”¾å›é˜Ÿåˆ—å¤´éƒ¨ (queue.offerFirst(message) å¦‚æœä½¿ç”¨ Deque)
                        // æˆ–è€…æŠŠå®ƒç§»åŠ¨åˆ°ä¸€ä¸ªç‰¹æ®Šçš„é‡è¯•é˜Ÿåˆ—ã€‚
                        // ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾å¤±è´¥å°±ä¸¢å¼ƒæˆ–åœ¨æ—¥å¿—ä¸­è®°å½•ã€‚
                        if (result == Publication.BACK_PRESSURED) {
                            // å¦‚æœèƒŒå‹ï¼Œå¯ä»¥å°† message æ”¾å›é˜Ÿåˆ—ï¼Œç„¶å break å†…éƒ¨å¾ªç¯ï¼Œ
                            // è®©å¤–éƒ¨å¾ªç¯ç»§ç»­è½®è¯¢å…¶ä»– publicationï¼Œä¸‹ä¸€è½®å†é‡è¯•å½“å‰ publication
                            // è¿™é‡Œä¸ºäº†ç¤ºä¾‹ï¼Œå…ˆç®€åŒ–å¤„ç†ã€‚
                            log.warn("Publication back-pressured for key: {}", key);
                            // é‡åˆ°èƒŒå‹ï¼Œå…ˆåœæ­¢å¤„ç†å½“å‰é˜Ÿåˆ—ï¼Œè®©å‡º CPU ç»™å…¶ä»– Publication
                            break;
                        } else if (result == Publication.NOT_CONNECTED) {
                            log.error("Publication not connected for key: {}", key);
                        } else {
                            log.error("Publication offer failed with result: {} for key: {}", result, key);
                        }
                    }
                }
            }

            if (!messagesPublished) {
                idleStrategy.idle();
            } else {
                idleStrategy.reset();
            }
        }
    }
}



@UtilityClass
public final class TimeKit {
    public long elapsedMillis(long nanoTime) {
        return (System.nanoTime() - nanoTime) / 1_000_000;
    }

    public long elapsedMicros(long nanoTime) {
        return (System.nanoTime() - nanoTime) / 1_000;
    }
}

@UtilityClass
public final class DevKit {
    public AtomicBoolean devEnterprise = new AtomicBoolean();

    public BlockingQueue<Long> requestOnFragmentTimes = new LinkedBlockingQueue<>();
    public BlockingQueue<Long> handleTimes = new LinkedBlockingQueue<>();
    public BlockingQueue<Long> callTimes = new LinkedBlockingQueue<>();
    public BlockingQueue<Long> ofFutureTimes = new LinkedBlockingQueue<>();
    public BlockingQueue<Long> ofFutureGetTimes = new LinkedBlockingQueue<>();
    public BlockingQueue<Long> requestSbeTimes = new LinkedBlockingQueue<>();
    public BlockingQueue<Long> responseSbeTimes = new LinkedBlockingQueue<>();
    public LongAdder avgMicrosTime = new LongAdder();

    public void requestSbeTimes(long nanoTime) {
        requestSbeTimes.offer(System.nanoTime() - nanoTime);
    }

    public void responseSbeTimes(long nanoTime) {
        responseSbeTimes.offer(System.nanoTime() - nanoTime);
    }

    public void ofFutureTimes(long nanoTime) {
        ofFutureTimes.offer(System.nanoTime() - nanoTime);
    }
    public void ofFutureGetTimes(long nanoTime) {
        ofFutureGetTimes.offer(System.nanoTime() - nanoTime);
    }

    public void requestOnFragmentTimes(long nanoTime) {
        requestOnFragmentTimes.offer(System.nanoTime() - nanoTime);
    }

    public void handleTimes(long nanoTime) {
        handleTimes.offer(System.nanoTime() - nanoTime);
    }

    public void callTimes(long nanoTime) {
        callTimes.offer(System.nanoTime() - nanoTime);
    }

    public void reset() {
        ofFutureTimes.clear();
        requestSbeTimes.clear();
        ofFutureGetTimes.clear();

        requestOnFragmentTimes.clear();
        handleTimes.clear();
        responseSbeTimes.clear();


        callTimes.clear();
        avgMicrosTime.reset();
    }

    public String toString(String title, BlockingQueue<Long> times) {
        return new DataPanel(title, times).toString();
    }

    private static class DataPanel {
        final String title;
        final BlockingQueue<Long> times;
        long sumTime;

        DataPanel(String title, BlockingQueue<Long> times) {
            this.title = title;
            this.times = times;
        }

        @Override
        public String toString() {

            int size = times.size();

            Long value;
            while ((value = times.poll()) != null) {
                sumTime += value;
            }

            avgMicrosTime.add(sumTime / size / 1_000);

            return """
                    title: %s
                    size: %s
                    sumTime: %,d
                    avgMicros: %,d
                    avgMillis: %,d
                    -----------------------
                    """.formatted(title
                    , size
                    , sumTime
                    , sumTime / size / 1_000
                    , sumTime / size / 1_000_000
            );
        }
    }
}

public class RequestMessageOnFragment extends AbstractRequestOnFragment {
    protected final RequestMessageDecoder decoder = new RequestMessageDecoder();

    @Override
    public void process(DirectBuffer buffer, int offset, int actingBlockLength, int actingVersion, Header header) {
        long nanoTime = System.nanoTime();
        decoder.wrap(buffer, offset, actingBlockLength, actingVersion);

        var message = new RequestMessage();
        SbeKit.decoderMessageCommon(message, decoder.common());
        SbeKit.decoderUserIdentity(message, decoder.userIdentity());

        message.setHopCount(decoder.hopCount());

        extracted(message);

        var dataLength = decoder.dataLength();
        var dataBytes = ByteKit.ofBytes(dataLength);
        decoder.getData(dataBytes, 0, dataLength);
        message.setData(dataBytes);

        var attachmentLength = decoder.attachmentLength();
        var attachmentBytes = ByteKit.ofBytes(attachmentLength);
        decoder.getAttachment(attachmentBytes, 0, attachmentLength);
        message.setAttachment(attachmentBytes);

        commonProcess(message, CommunicationType.INTERNAL_CALL);

        log.info("userId:{} - {}", message.getUserId(),
                TimeKit.elapsedMicros(message.getNanoTime())
        );

        DevKit.requestOnFragmentTimes(nanoTime);
    }

    protected void extracted(RequestMessage message) {
        decoder.bindingLogicServerIds();
    }

    @Override
    public int getTemplateId() {
        return RequestMessageDecoder.TEMPLATE_ID;
    }
}

Aeron å’Œ MediaDriver é…ç½®å¦‚ä¸‹
public class AeronLifecycleManager {
    static final Logger log = LoggerFactory.getLogger(AeronLifecycleManager.class);

    // 10 åˆ†é’Ÿ (600 ç§’) çš„çº³ç§’å€¼
    public static final long DEBUG_CLIENT_TIMEOUT_NS = 600_000_000_000L;
    // 10 åˆ†é’Ÿ (600 ç§’) çš„æ¯«ç§’å€¼ï¼Œç”¨äº aeron.driver.timeout
    public static final long DEBUG_DRIVER_TIMEOUT_MS = 600_000L;
    // 15 åˆ†é’Ÿ (900 ç§’) çš„çº³ç§’å€¼
    public static final long DEBUG_UNBLOCK_TIMEOUT_NS = 900_000_000_000L;
    // ç•¥å¤§äº 10 åˆ†é’Ÿçš„çº³ç§’å€¼
    public static final long DEBUG_INTER_SERVICE_TIMEOUT_NS = DEBUG_CLIENT_TIMEOUT_NS + 1_000_000_000L;

    static {
        // ğŸš€ 1. å»¶é•¿å®¢æˆ·ç«¯ç­‰å¾… Driver å‡ºç°çš„å¿ƒè·³è¶…æ—¶ (å•ä½: æ¯«ç§’)
        System.setProperty("aeron.driver.timeout", String.valueOf(DEBUG_DRIVER_TIMEOUT_MS));

        // ğŸš€ 2. å»¶é•¿å®¢æˆ·ç«¯ä¿æ´»é—´éš” (å•ä½: çº³ç§’)
        System.setProperty("aeron.keepAliveIntervalNs", String.valueOf(DEBUG_CLIENT_TIMEOUT_NS));

        // ğŸš€ 3. å»¶é•¿å®¢æˆ·ç«¯é›†ç¾¤æœåŠ¡è¶…æ—¶ï¼Œè§£å†³é…ç½®æ ¡éªŒ (å•ä½: çº³ç§’)
        System.setProperty("aeron.interServiceTimeoutNs", String.valueOf(DEBUG_INTER_SERVICE_TIMEOUT_NS));
    }

    private MediaDriver mediaDriver;
    private Aeron aeron;

    public static String getAeronDirectoryName() {
        return "%s-%s".formatted(CommonContext.getAeronDirectoryName(), "ionet");
    }

    public AeronLifecycleManager() {
        initMediaDriver();
        initAeron();

        Runtime.getRuntime().addShutdownHook(new Thread(this::destroy));
    }

    public Aeron getAeron() {
        return aeron;
    }

    // MediaDriver Bean
    private MediaDriver initMediaDriver() {

        if (mediaDriver != null) {
            return mediaDriver;
        }

        log.info("Starting Aeron Embedded Media Driver...");
        var mediaDriverCtx = new MediaDriver.Context()
                // è®¾ç½®å®¢æˆ·ç«¯å¿ƒè·³è¶…æ—¶æ—¶é—´ (ç¡®ä¿ Driver çŸ¥é“ Client 10åˆ†é’Ÿåæ‰æ–­å¼€)
                .clientLivenessTimeoutNs(DEBUG_CLIENT_TIMEOUT_NS)
                // è®¾ç½®å‘å¸ƒè§£é™¤é˜»å¡è¶…æ—¶æ—¶é—´ (å¿…é¡»å¤§äºå¿ƒè·³è¶…æ—¶)
                .publicationUnblockTimeoutNs(DEBUG_UNBLOCK_TIMEOUT_NS)
                // ç¡®ä¿ä½¿ç”¨ç‹¬ç‰¹çš„ç›®å½•åå¹¶éš”ç¦»ï¼Œé¿å…ä¸å…¶ä»– Media Driver å†²çª
                // Ensure a unique and isolated directory name is used to avoid conflicts with other Media Drivers
                .aeronDirectoryName(getAeronDirectoryName())
//                .sharedIdleStrategy(new SleepingMillisIdleStrategy(1))
                .sharedIdleStrategy(new BusySpinIdleStrategy())
                // å¯åŠ¨æ—¶æ¸…ç†æ—§ç›®å½•ï¼Œè§£å†³æ®‹ç•™æ–‡ä»¶é—®é¢˜
                // Clean up old directories on startup to resolve residual file issues
                .dirDeleteOnStart(true)
                // å…³é—­æ—¶æ¸…ç†ç›®å½•
                // Clean up directory on shutdown
                .dirDeleteOnShutdown(true)
                // ä½¿ç”¨ä¸“ç”¨çº¿ç¨‹æ¨¡å¼
                // Use dedicated threading mode
                .threadingMode(ThreadingMode.DEDICATED);

        this.mediaDriver = MediaDriver.launchEmbedded(mediaDriverCtx);
        log.info("Aeron Media Driver started at: {}", this.mediaDriver.aeronDirectoryName());

        try {
            // å¯åŠ¨åæš‚åœï¼Œç¡®ä¿é©±åŠ¨ç¨‹åºå®Œæˆå†…éƒ¨åˆå§‹åŒ–
            // Pause after startup to ensure the driver completes its internal initialization
            Thread.sleep(100);
        } catch (InterruptedException ignore) {
            Thread.currentThread().interrupt();
        }

        return mediaDriver;
    }

    // Aeron Client Bean
    private void initAeron() {
        log.info("Connecting Aeron Client...");
        var aeronCtx = new Aeron.Context();
        aeronCtx.driverTimeoutMs(DEBUG_DRIVER_TIMEOUT_MS);

//        aeronCtx.idleStrategy(new SleepingMillisIdleStrategy(1));
        aeronCtx.idleStrategy(new BusySpinIdleStrategy());

        // ç¡®ä¿å®¢æˆ·ç«¯è¿æ¥åˆ°é©±åŠ¨ç¨‹åºä½¿ç”¨çš„ç›®å½•
        // Ensure the client connects to the directory used by the driver
        aeronCtx.aeronDirectoryName(getAeronDirectoryName());

        var handler = new DefaultUnavailableImageHandler();
        aeronCtx.unavailableImageHandler(handler);
        aeronCtx.availableImageHandler(handler);

        // ä½¿ç”¨æ›´å¥å£®çš„è¿æ¥æ–¹æ³•ï¼Œä¾‹å¦‚è®¾ç½®è¶…æ—¶ï¼Œæˆ–è€…ç®€å•è¿æ¥
        // Use a more robust connection method, such as setting a timeout, or a simple connect
        this.aeron = Aeron.connect(aeronCtx);
        log.info("Aeron Client connected.");
    }

    private void destroy() {
        log.info("Shutting down Aeron client and Media Driver...");
        if (aeron != null) {
            try {
                aeron.close();
            } catch (Exception e) {
                log.error("Error closing Aeron client: {}", e.getMessage());
            }
        }

        if (mediaDriver != null) {
            try {
                mediaDriver.close();
            } catch (Exception e) {
                log.error("Error closing Media Driver: {}", e.getMessage());
            }
        }

        log.info("Aeron components shut down successfully.");
    }
}

æˆ‘åœ¨ mvc test æ–¹æ³•ä¸­åšäº†ä¸€äº›æ‰“å°ï¼Œå¹³å‡åªç”¨äº† 40 å¾®å¦™ï¼Œæ‰“å°å¦‚ä¸‹
```text
millis:234
avgMicrosTime:40

title: call-FutureTimes
size: 100
sumTime: 314,807
avgMicros: 3
avgMillis: 0
-----------------------

title: call-requestSbeTimes
size: 100
sumTime: 372,004
avgMicros: 3
avgMillis: 0
-----------------------


title: requestOnFragmentTimes
size: 100
sumTime: 1,436,407
avgMicros: 14
avgMillis: 0
-----------------------

title: handleTimes
size: 100
sumTime: 1,709,916
avgMicros: 17
avgMillis: 0
-----------------------

title: responseSbeTimes
size: 100
sumTime: 363,084
avgMicros: 3
avgMillis: 0
-----------------------
```